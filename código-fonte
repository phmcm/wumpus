#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>


#define MAX_NOME 50
#define Tamanho_tabuleiro 8

int tabuleiroo[Tamanho_tabuleiro][Tamanho_tabuleiro];
int encontrou_ouro;
int flecha;

void iniciar_tabuleiro()
{
    srand(time(NULL));

    // inicializar tabuleiro com todos os elementos iguais a zero
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            tabuleiroo[i][j] = 0;
        }
    }

    // posicionar o agente na posição (A,1)
    tabuleiroo[0][0] = 1;

    // posicionar o ouro em uma posição aleatória
    int ouro_linha = rand() % Tamanho_tabuleiro;
    int ouro_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[ouro_linha][ouro_coluna] != 0)
    {
        ouro_linha = rand() % Tamanho_tabuleiro;
        ouro_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[ouro_linha][ouro_coluna] = 2;

    // posicionar os poços em posições aleatórias
    int count_pocos = 0;
    while (count_pocos < 5) // garantir que sejam posicionados exatamente 5 poços
    {
        int poco_linha = rand() % Tamanho_tabuleiro;
        int poco_coluna = rand() % Tamanho_tabuleiro;
        if (tabuleiroo[poco_linha][poco_coluna] == 0) // apenas posicionar o poço se a posição estiver vazia
        {
            tabuleiroo[poco_linha][poco_coluna] = 5;
            count_pocos++;
        }
    }

    // posicionar o monstro em uma posição aleatória
    int monstro_linha = rand() % Tamanho_tabuleiro;
    int monstro_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[monstro_linha][monstro_coluna] != 0)
    {
        monstro_linha = rand() % Tamanho_tabuleiro;
        monstro_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[monstro_linha][monstro_coluna] = 3;

    // posicionar a flecha em uma posição aleatória
    int flecha_linha = rand() % Tamanho_tabuleiro;
    int flecha_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[flecha_linha][flecha_coluna] != 0)
    {
        flecha_linha = rand() % Tamanho_tabuleiro;
        flecha_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[flecha_linha][flecha_coluna] = 4;
}

// TABULEIRO NORMAL(TA PRONTO JA)
void mostrar_tabuleiro()
{
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                if (tabuleiroo[i][j] == 1)
                {
                    printf("A ");
                }
                else
                {
                    printf("# ");
                }
            }
            else
            {
                printf("# ");
            }
        }
        printf("\n");
    }
}

// TABULEIRO COM DEBUG(TA PRONTO)
void mostrar_tabuleiroDEBUG()
{
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            switch (tabuleiroo[i][j])
            {
            case 0:
                printf("#");
                break;
            case 1:
                printf("A");
                break;
            case 2:
                printf("$");
                break;
            case 3:
                printf("M");
                break;
            case 4:
                printf("F");
                break;
            case 5:
                printf("P");
                break;
            }
            printf(" ");
        }
        printf("\n");
    }
}
int atirarFlecha(int x, int y, int inimigo_x, int inimigo_y)
{
    if (monstroPerto(x, y))
        return (x == inimigo_x) || (y == inimigo_y);
    return 0;
}
int mover_agente(char comando)
{
    int nova_linha, nova_coluna;

    // encontrar a posição atual do agente na matriz
    int agente_linha, agente_coluna;
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                agente_linha = i;
                agente_coluna = j;
            }
        }
    }

    // calcular a nova posição do agente com base no comando de movimento
    switch (comando)
    {
    case 'N':
        nova_linha = agente_linha - 1;
        nova_coluna = agente_coluna;
        break;
    case 'S':
        nova_linha = agente_linha + 1;
        nova_coluna = agente_coluna;
        break;
    case 'W':
        nova_linha = agente_linha;
        nova_coluna = agente_coluna - 1;
        break;
    case 'E':
        nova_linha = agente_linha;
        nova_coluna = agente_coluna + 1;
        break;
    default:
        // comando inválido
        return 0;
    }
    // verificar se a nova posição é válida
    if (nova_linha < 0 || nova_linha >= Tamanho_tabuleiro || nova_coluna < 0 || nova_coluna >= Tamanho_tabuleiro)
    {
        return 0;
    }

    if (tabuleiroo[nova_linha][nova_coluna] == 5)
    {
        printf("\n\nVocê caiu no poço! Eu falei para você tomar cuidado 😠\n\n");
        exit(0);
    }
    else if (tabuleiroo[nova_linha][nova_coluna] == 3)
    {
        printf("\nO monstro te pegou ):\n\n");
        exit(0);
    }
    if (tabuleiroo[nova_linha][nova_coluna] == 2)
    {
        printf("\n\nVocê achou o ouro.\n\n");
        encontrou_ouro = 1;
    }
    if (tabuleiroo[nova_linha][nova_coluna] == 4)
    {
        printf("\n\nVocê achou uma flecha!\n\n");
        flecha = 1;
    }
    // atualizar a posição do agente na matriz tabuleiroo
    tabuleiroo[agente_linha][agente_coluna] = 0;
    tabuleiroo[nova_linha][nova_coluna] = 1;
    return 0;
}
void mover_monstro(int *nova_linha, int *nova_coluna)
{
    // encontrar a posição atual do monstro na matriz tabuleiroo
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 3)
            {
                *nova_linha = i;
                *nova_coluna = j;
            }
        }
    }
    // escolher uma direção aleatória para o movimento do monstro
    int direcao = rand() % 7; // 0=norte, 1=sul, 2=oeste, 3=leste
    int temp_linha = *nova_linha;
    int temp_coluna = *nova_coluna;
    switch (direcao)
    {
    case 0:
        *nova_linha -= 1;
        break;
    case 1:
        *nova_linha += 1;
        break;
    case 2:
        *nova_coluna -= 1;
        break;
    case 3:
        *nova_coluna += 2;
        break;
    case 4:
        *nova_linha += 7;
        break;
    case 5:
        *nova_linha -= 4;
        break;
    case 6:
        *nova_coluna += 5;
        break;
    case 7:
        *nova_coluna -= 4;
        break;
    }
    // verificar se a nova posição é válida (dentro do tabuleiro)
    if (temp_linha < 0 || temp_linha >= Tamanho_tabuleiro || temp_coluna < 0 || temp_coluna >= Tamanho_tabuleiro)
    {
        return;
    }

    if (tabuleiroo[temp_linha][temp_coluna] == 5)
    {
        return;
    }
    if (tabuleiroo[temp_linha][temp_coluna] == 2)
    {
        return;
    }
    if (tabuleiroo[temp_linha][temp_coluna] == 4)
    {
        return;
    }
    if (tabuleiroo[temp_linha][temp_coluna] == 1)
    {
        printf("O monstro te pegou \xF0\x9F\x98\xA2.");
        exit(0);
    }
    // atualizar a posição do monstro na matriz tabuleiroo
    tabuleiroo[*nova_linha][*nova_coluna] = 0;
    tabuleiroo[temp_linha][temp_coluna] = 3;
    printf("\nO monstro se movimentou!\n\n");
}
int monstroPerto(int *agente_linha, int *agente_coluna)
{
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 3)
            {
                int distancia_linha = abs(i - *agente_linha);
                int distancia_coluna = abs(j - *agente_coluna);
                return (distancia_linha + distancia_coluna == 1);
            }
        }
    }
    return 0;
}
typedef struct {
    char nome[MAX_NOME];
    int movimentos;
} Jogador;

int compara_jogadores(const void *a, const void *b) {
    const Jogador *ja = (const Jogador*) a;
    const Jogador *jb = (const Jogador*) b;
    return (ja->movimentos - jb->movimentos);
}

void grava_partida(int movimentos) {
    FILE *arquivo;
    Jogador jogador;
    int n_jogadores = 0, i;

    printf("Fim da partida! Você fez %d movimentos.\n", movimentos);
    printf("Digite seu nome: ");
    scanf("%s", jogador.nome);
    jogador.movimentos = movimentos;

    // Abre o arquivo no modo "a" (append)
    arquivo = fopen("partida.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo!\n");
        exit(1);
    }

    // Escreve o novo jogador no arquivo
    fwrite(&jogador, sizeof(Jogador), 1, arquivo);

    // Conta o número de jogadores já registrados no arquivo
    fseek(arquivo, 0, SEEK_END);
    n_jogadores = ftell(arquivo) / sizeof(Jogador);

    // Ordena os jogadores em ordem crescente de movimentos
    Jogador *jogadores = (Jogador*) malloc(n_jogadores * sizeof(Jogador));
    rewind(arquivo);
    for (i = 0; i < n_jogadores; i++) {
        fread(&jogadores[i], sizeof(Jogador), 1, arquivo);
    }
    qsort(jogadores, n_jogadores, sizeof(Jogador), compara_jogadores);

    // Reescreve o arquivo com a lista de jogadores ordenada
    rewind(arquivo);
    for (i = 0; i < n_jogadores; i++) {
        fwrite(&jogadores[i], sizeof(Jogador), 1, arquivo);
    }

    // Fecha o arquivo e libera a memória alocada
    fclose(arquivo);
    free(jogadores);

    printf("Dados gravados com sucesso!\n");
}

// TESTESSSSSS
void mensagem_campeao(int mov)
{
    // Encontrar a posição do agente no tabuleiro
    int agente_linha, agente_coluna;
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                agente_linha = i;
                agente_coluna = j;
            }
        }
    }

    if (encontrou_ouro && agente_linha == 0 && agente_coluna == 0)
    {
        system("cls");
        printf("\n\nParabéns, você conseguiu escapar com o ouro. \n\nAgora você já pode se matricular na cadeira de AED1 👍\n");
        grava_partida(mov);

    }
}


void mensagem(int *agente_linha, int *agente_coluna)
{
    // Encontrar a posição do agente no tabuleiro
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                *agente_linha = i;
                *agente_coluna = j;
            }
        }
    }
    // Verificar a posição do agente em relação ao poço
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 5)
            {
                int distancia_linha = abs(i - *agente_linha);
                int distancia_coluna = abs(j - *agente_coluna);
                if (distancia_linha + distancia_coluna == 1)
                {
                    printf("\nCuidado pra não cair!\n");
                    return;
                }
            }
        }
    }
    // Verificar a posição do agente em relação ao monstro
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 3)
            {
                int distancia_linha = abs(i - *agente_linha);
                int distancia_coluna = abs(j - *agente_coluna);
                if (distancia_linha + distancia_coluna == 1)
                {
                    printf("\nOlha o bixo papão hein!\n");
                    return;
                }
            }
        }
    }
}
int main()
{
    system("chcp 65001 > NUL");
    int x, acao,mov;
    char tiro;
    int nova_linha, nova_coluna, agente_linha, agente_coluna;
    printf("=============================\n");
    printf("------O Mundo de Wumpus------\n");
    printf("=============================\n\n");
    printf("MENU:\n1- |Jogar|\n2- |Debug|\n3- |Ranking|\n4- |Sair|\n\nSua escolha:");
    scanf("%d", &x);
    if (x < 1 || x > 4)
        do
        {
            printf("\nOpcao invalida, digite outro valor:");
            scanf("%d", &x);
        } while (x < 1 || x > 4);
    switch (x)
    {
    case 1: // opção de Jogar
        printf("\n");
        iniciar_tabuleiro();
        mostrar_tabuleiro();
        char comando;
        while (1)
        {
            if (encontrou_ouro == 1)
            {
                printf("\nVocê está com o ouro. FUGA!");
            }
            if (flecha == 1)
            {
                printf("\n\nVocê tem uma Flecha. Use com responsabilidade!");
            }
            printf("\n\nDigite uma direcao para mover o agente (N/S/E/W):");
            scanf(" %c", &comando);
            system("cls");

            if (!mover_agente(comando))
            {
                printf("Movimento invalido.\n\n");
            }
            mov++;
            mover_monstro(&nova_linha, &nova_coluna);
            mostrar_tabuleiro();
            mensagem(&agente_linha, &agente_coluna);
            mensagem_campeao(mov);
        }
        break;
    case 2: // opção de Debug
        printf("\n");
        iniciar_tabuleiro();
        mostrar_tabuleiroDEBUG();

        while (2)
        {
            if (encontrou_ouro == 1)
            {
                printf("\nVocê está com o ouro. FUJA!");
            }

            if (flecha == 1)
            {
                printf("\n\nVocê tem uma Flecha. Use com responsabilidade!");
            }
            printf("\n\nO que deseja fazer:\n1-Andar\n2-Atirar a flecha\n");
            scanf("%d", &acao);
            switch (acao)
            {
            case 1:
                printf("\n\nDigite uma direcao para mover o agente (N/S/E/W):");
                scanf(" %c", &comando);
                system("cls");
                if (!mover_agente(comando))
                {
                    printf("Movimento invalido.\n\n");
                }
                mov++;
                break;
            case 2:
                if (flecha != 1)
                {
                    system("cls");
                    printf("Você não possui uma flecha");
                }
                else
                {
                    system("cls");
                    if (atirarFlecha(agente_linha, agente_coluna, nova_linha, nova_coluna))
                    {
                        printf("Você Matou o Monstro!");
                    }
                    else
                    {
                        printf("Você errou");
                    }
                    flecha = 0;
                }
                break;
            }
            comando = ' ';
            mover_monstro(&nova_linha, &nova_coluna);
            mostrar_tabuleiroDEBUG();
            mensagem(&agente_linha, &agente_coluna);
            mensagem_campeao(mov);
        }
        break;
    case 3: // opção Ranking
        return 0;
        break;
    case 4:
        printf("\n");
        return 0; // fecha o Jogo
        break;
    }
    return 0;
}



FALTA ARRUMAR OS WHILE
TERMINAR O TIRO DA FLECHA E O MENU FINAL
ABRIR O ARQUIVO DO RANKING
