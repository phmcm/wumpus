#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define Tamanho_tabuleiro 8

int tabuleiroo[Tamanho_tabuleiro][Tamanho_tabuleiro];
int Tabuleiro_visivel[Tamanho_tabuleiro][Tamanho_tabuleiro];
int encontrou_ouro;
int flecha;

void iniciar_tabuleiro()
{
    // inicializar gerador de números aleatórios
    srand(time(NULL));

    // inicializar tabuleiro com todos os elementos iguais a zero
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            tabuleiroo[i][j] = 0;
        }
    }

    // posicionar o agente na posição (A,1)
    tabuleiroo[0][0] = 1;

    // posicionar o ouro em uma posição aleatória (não pode ser colocada em uma posição que já contenha um poço ou o agente)
    int ouro_linha = rand() % Tamanho_tabuleiro;
    int ouro_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[ouro_linha][ouro_coluna] != 0 && tabuleiroo[ouro_linha][ouro_coluna] != 1 && tabuleiroo[ouro_linha][ouro_coluna] != 5 && tabuleiroo[ouro_linha][ouro_coluna] != 4)
    {
        ouro_linha = rand() % Tamanho_tabuleiro;
        ouro_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[ouro_linha][ouro_coluna] = 2;

    // posicionar os poços em posições aleatórias
    for (int i = 0; i < 5; i++)
    {
        int poco_linha = rand() % Tamanho_tabuleiro;
        int poco_coluna = rand() % Tamanho_tabuleiro;
        while (tabuleiroo[poco_linha][poco_coluna] != 0 && tabuleiroo[poco_linha][poco_coluna] != 2  && tabuleiroo[poco_linha][poco_coluna] != 3)
        {
            poco_linha = rand() % Tamanho_tabuleiro;
            poco_coluna = rand() % Tamanho_tabuleiro;
        }
        tabuleiroo[poco_linha][poco_coluna] = 5;
    }

    // posicionar o monstro em uma posição aleatória (não pode ser colocada em uma posição que já contenha um poço ou o agente)
    int monstro_linha = rand() % Tamanho_tabuleiro;
    int monstro_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[monstro_linha][monstro_coluna] != 0 && tabuleiroo[monstro_linha][monstro_coluna] != 5  && tabuleiroo[monstro_linha][monstro_coluna] != 2   && tabuleiroo[monstro_linha][monstro_coluna] != 4)
    {
        monstro_linha = rand() % Tamanho_tabuleiro;
        monstro_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[monstro_linha][monstro_coluna] = 3;

    // posicionar a flecha em uma posição aleatória (não pode ser colocada em uma posição que já contenha um poço, o agente ou o monstro)
    int flecha_linha = rand() % Tamanho_tabuleiro;
    int flecha_coluna = rand() % Tamanho_tabuleiro;
    while (tabuleiroo[flecha_linha][flecha_coluna] != 0 && tabuleiroo[flecha_linha][flecha_coluna] != 3 && tabuleiroo[flecha_linha][flecha_coluna] != 5  && tabuleiroo[flecha_linha][flecha_coluna] != 2)
    {
        flecha_linha = rand() % Tamanho_tabuleiro;
        flecha_coluna = rand() % Tamanho_tabuleiro;
    }
    tabuleiroo[flecha_linha][flecha_coluna] = 4;

    // inicializar a matriz Tabuleiro_visivel com todos os elementos iguais a zero
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            Tabuleiro_visivel[i][j] = 0;
        }
    }

    // definir as posições visíveis no tabuleiro (posição do agente e posições adjacentes)
    Tabuleiro_visivel[0][0] = 1;
    if (ouro_linha == 0 && ouro_coluna == 1)
    {
        Tabuleiro_visivel[0][1] = 1;
    }

    if (monstro_linha == 0 && monstro_coluna == 1)
    {
        Tabuleiro_visivel[0][1] = 1;
    }
    if (ouro_linha == 1 && ouro_coluna == 0)
    {
        Tabuleiro_visivel[1][0] = 1;
    }
    if (monstro_linha == 1 && monstro_coluna == 0)
    {
        Tabuleiro_visivel[1][0] = 1;
    }
}

// TABULEIRO NORMAL(TA PRONTO JA)
/*void mostrar_tabuleiro()
{
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (Tabuleiro_visivel[i][j] == 1)
            {
                if (tabuleiroo[i][j] == 1)
                {
                    printf("A ");
                }
                else
                {
                    printf("# ");
                }
            }
            else
            {
                printf("# ");
            }
        }
        printf("\n");
    }
}*/

// TABULEIRO COM DEBUG(TA PRONTO)
void mostrar_tabuleiroDEBUG()
{
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            switch (tabuleiroo[i][j])
            {
            case 0:
                printf("#");
                break;
            case 1:
                printf("A");
                break;
            case 2:
                printf("$");
                break;
            case 3:
                printf("M");
                break;
            case 4:
                printf("F");
                break;
            case 5:
                printf("P");
                break;
            }
            printf(" ");
        }
        printf("\n");
    }
}

int mover_agente(char comando)
{
    int nova_linha, nova_coluna;

    // encontrar a posição atual do agente na matriz board
    int agente_linha, agente_coluna;
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                agente_linha = i;
                agente_coluna = j;
            }
        }
    }

    // calcular a nova posição do agente com base no comando de movimento
    switch (comando)
    {
    case 'N':
        nova_linha = agente_linha - 1;
        nova_coluna = agente_coluna;
        break;
    case 'S':
        nova_linha = agente_linha + 1;
        nova_coluna = agente_coluna;
        break;
    case 'W':
        nova_linha = agente_linha;
        nova_coluna = agente_coluna - 1;
        break;
    case 'E':
        nova_linha = agente_linha;
        nova_coluna = agente_coluna + 1;
        break;
    default:
        // comando inválido
        return 0;
    }

    // verificar se a nova posição é válida (dentro do tabuleiro)
    if (nova_linha < 0 || nova_linha >= Tamanho_tabuleiro || nova_coluna < 0 || nova_coluna >= Tamanho_tabuleiro)
    {
        return 0;
    }

    // verificar se a nova posição não contém um poço
    if (tabuleiroo[nova_linha][nova_coluna] == 5)
    {
        printf("\nVocê caiu no poço ):");
        exit(0);
    }

    else if (tabuleiroo[nova_linha][nova_coluna] == 3)
    {
        printf("\nO monstro te pegou ):");
        exit(0);
    }

    if (tabuleiroo[nova_linha][nova_coluna] == 2)
    {
        printf("\nVocê achou o ouro!\n");
        encontrou_ouro = 1;
    }

    if (tabuleiroo[nova_linha][nova_coluna] == 4)
    {
        printf("\nVocê achou uma flecha!\n");
        flecha = 1;
    }

    if (Tabuleiro_visivel[0][0] && encontrou_ouro == 1)
{
    printf("\nVocê ganhou o jogo! Parabéns!\n");
    exit(0);
}

    // atualizar a posição do agente na matriz tabuleiroo
    tabuleiroo[agente_linha][agente_coluna] = 0;
    tabuleiroo[nova_linha][nova_coluna] = 1;

    // atualizar a matriz Tabuleiro_visivel com as novas posições visíveis
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            Tabuleiro_visivel[i][j] = 0;
        }
    }
    Tabuleiro_visivel[nova_linha][nova_coluna] = 1;
    if (nova_linha > 0)
    {
        Tabuleiro_visivel[nova_linha - 1][nova_coluna] = 1;
    }
    if (nova_linha < Tamanho_tabuleiro - 1)
    {
        Tabuleiro_visivel[nova_linha + 1][nova_coluna] = 1;
    }
    if (nova_coluna > 0)
    {
        Tabuleiro_visivel[nova_linha][nova_coluna - 1] = 1;
    }
    if (nova_coluna < Tamanho_tabuleiro - 1)
    {
        Tabuleiro_visivel[nova_linha][nova_coluna + 1] = 1;
    }

    return 1;
}

void mover_monstro()
{
    // encontrar a posição atual do monstro na matriz tabuleiroo
    int monstro_linha, monstro_coluna;
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 3)
            {
                monstro_linha = i;
                monstro_coluna = j;
            }
        }
    }

    // escolher uma direção aleatória para o movimento do monstro
    int direcao = rand() % 4; // 0=norte, 1=sul, 2=oeste, 3=leste
    int nova_linha = monstro_linha;
    int nova_coluna = monstro_coluna;
    switch (direcao)
    {
    case 0:
        nova_linha = monstro_linha - 1;
        break;
    case 1:
        nova_linha = monstro_linha + 1;
        break;
    case 2:
        nova_coluna = monstro_coluna - 1;
        break;
    case 3:
        nova_coluna = monstro_coluna + 2;
        break;
    case 4:
        nova_linha = monstro_linha + 7;
        break;
    case 5:
        nova_linha = monstro_linha - 4;
        break;
    case 6:
        nova_coluna = monstro_coluna + 5;
        break;
    case 7:
        nova_coluna = monstro_coluna - 4;
        break;
    }

    // verificar se a nova posição é válida (dentro do tabuleiro)
    if (nova_linha < 0 || nova_linha >= Tamanho_tabuleiro || nova_coluna < 0 || nova_coluna >= Tamanho_tabuleiro)
    {
        return;
    }

    // verificar se a nova posição não contém um poço ou o agente
    if (tabuleiroo[nova_linha][nova_coluna] == 5 || tabuleiroo[nova_linha][nova_coluna] == 1)
    {
        return;
    }

    // atualizar a posição do monstro na matriz tabuleiroo
    tabuleiroo[monstro_linha][monstro_coluna] = 0;
    tabuleiroo[nova_linha][nova_coluna] = 3;
}

// TESTESSSSSS

void mensagem()
{
    int agente_linha, agente_coluna;
    // Encontrar a posição do agente no tabuleiro
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 1)
            {
                agente_linha = i;
                agente_coluna = j;
            }
        }
    }

    // Verificar a posição do agente em relação ao poço
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 5)
            {
                int distancia_linha = abs(i - agente_linha);
                int distancia_coluna = abs(j - agente_coluna);
                if (distancia_linha + distancia_coluna == 1)
                {
                    printf("\n\nCuidado pra não cair!\n");
                    return;
                }
            }
        }
    }

    // Verificar a posição do agente em relação ao monstro
    for (int i = 0; i < Tamanho_tabuleiro; i++)
    {
        for (int j = 0; j < Tamanho_tabuleiro; j++)
        {
            if (tabuleiroo[i][j] == 3)
            {
                int distancia_linha = abs(i - agente_linha);
                int distancia_coluna = abs(j - agente_coluna);
                if (distancia_linha + distancia_coluna == 1)
                {
                    printf("\n\nOlha o bixo papão ein!\n");
                    return;
                }
            }
        }
    }
}

int main()
{
    system("chcp 65001 > NUL");
    int x;
    printf("=============================\n");
    printf("------O Mundo de Wumpus------\n");
    printf("=============================\n\n");
    printf("MENU:\n1- |Jogar|\n2- |Debug|\n3- |Ranking|\n4- |Sair|\nSua escolha:");
    scanf("%d", &x);
    if (x < 1 || x > 4)
        do
        {
            printf("\nOpcao invalida, digite outro valor:");
            scanf("%d", &x);
        } while (x < 1 || x > 4);
    switch (x)
    {
    case 1: // opção de Jogar
        iniciar_tabuleiro();
        mostrar_tabuleiroDEBUG();
        char comando;
        while (1)
        {
            if (encontrou_ouro == 1)
            {
                printf("\n\nVocê está com o ouro!");
            }

             if (flecha == 1)
            {
                printf("\n\nVocê tem uma Flecha. Use com responsabilidade!");
            }
            printf("\n\nDigite uma direcao para mover o agente (N/S/E/W):");
            scanf(" %c", &comando);
            system("cls");

            if (!mover_agente(comando))
            {
                printf("Movimento invalido.\n\n");
            }

            printf("\nO monstro se movimentou!\n\n");
            mover_monstro();

            mostrar_tabuleiroDEBUG();
            mensagem();
        }
        break;
    case 2:                             // opção de Debug
        printf("2iniciar_tabuleiro()"); // Fazer Versão Debug Mostrando Tudo
        printf("2mostrar_tabuleiro()"); // Fazer Versão Debug Mostrando Tudo
        break;
    case 3:                          // opção Ranking
        printf("mostrar_ranking()"); // criar função que mostra Ranking
        break;
    case 4:
        return 0; // fecha o Jogo
        break;
    }

    return 0;
}

/*
//código Ranking
#include <stdio.h>

int main() {
    FILE *fp;
    char nome[50];
    int movimentos;

    fp = fopen("jogadores.txt", "w"); // cria o arquivo "jogadores.txt"

    if (fp == NULL) {
        printf("Erro ao criar o arquivo.\n");
        return 1;
    }

    printf("Digite o nome do jogador e a quantidade de movimentos (separados por espaço).\n");
    printf("Digite 'fim' no nome para encerrar a entrada.\n");

    while (1) {
        scanf("%s", nome);

        if (strcmp(nome, "fim") == 0) {
            break;
        }

        scanf("%d", &movimentos);

        fprintf(fp, "%s %d\n", nome, movimentos); // salva o nome e a quantidade de movimentos no arquivo
    }

    fclose(fp); // fecha o arquivo

    return 0;
}



//função de Ranking
#include <stdio.h>
#include <stdlib.h>

int salvar_jogadores(char* nome_arquivo) {
    FILE *fp;
    char nome[50];
    int movimentos;

    fp = fopen(nome_arquivo, "w"); // cria o arquivo com o nome especificado

    if (fp == NULL) {
        printf("Erro ao criar o arquivo.\n");
        return 1;
    }

    printf("Digite o nome do jogador e a quantidade de movimentos (separados por espaco).\n");
    printf("Digite 'fim' no nome para encerrar a entrada.\n");

    while (1) {
        scanf("%s", nome);

        if (strcmp(nome, "fim") == 0) {
            break;
        }

        scanf("%d", &movimentos);

        fprintf(fp, "%s %d\n", nome, movimentos); // salva o nome e a quantidade de movimentos no arquivo
    }

    fclose(fp); // fecha o arquivo

    return 0;
}
*/
